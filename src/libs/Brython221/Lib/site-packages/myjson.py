'''myjson.py
I am trying to roll my own JSON coder for use in Brython.
Their's is not working for me.  It goes into an infinite loop or something, whenever it has to
encode an object which is an instance of one of my classes.
'''

primitive_types = [type(1), type(True), type(0.1)]
#def noChange(x): return x
def json_encode(o): #, default=noChange):
    if type(o) == type(""):
        return '"' + str(o) + '"'
    if type(o) in primitive_types:
        return str(o)
    if type(o) == type([]):
        return encode_list(o)
    if type(o) == type((0,1)):
        return encode_tuple(o)
    if type(o) == type({}):
        return encode_dict(o)
    d = pyObjectToDict(o)
    #print("The object is now a dict: "+str(d))
    #return 0/0 # halt
    return encode_dict(d)


def encode_key(k):
    return '"' + str(k) + '"'

def encode_dict(o):
    s = "{"
    for (k, v) in iter(o.items()):
        #print("So far, s = "+s)
        #print("k = " + str(k) + "; v = "+str(v))
        s += encode_key(k) + " : " + json_encode(v) + ", "
    if len(s)>1: s = s[:-2]
    s += " }"
    return s

def encode_list(o):
    d = {i : o[i] for i in range(len(o))}
    d["__myclass__"] = "list"
    return encode_dict(d)

def encode_tuple(o):
    d = {i : o[i] for i in range(len(o))}
    d["__myclass__"] = "tuple"
    return encode_dict(d)

#sample = [88, 1, 2.5, [True, False], {"fun": 3.141, 7:8}]
#print(json_encode(sample))

def json_decode(s):
    import json
    try:
     o = json.loads(s)
    except Exception as e:
     print("Exception in json.loads: "+str(e))
    return json_decode_dictionaries(o)

def json_decode_dictionaries(o):
    # Next, look inside of each collection for dict objects
    # that contain either __myclass__ or __constructor__ keys.
    # Turn those into lists or class instances.
    #print("In json_decode_dictionaries, o = "+str(o))
    if type(o) in primitive_types: return o
    if type(o)==type({}):
       o2 = { k : json_decode_dictionaries(v) for (k, v) in o.items() }
       if "__myclass__" in o2 and o2["__myclass__"]=="list":
          return json_decode_list(o2)
       if "__myclass__" in o2 and o2["__myclass__"]=="tuple":
          return json_decode_tuple(o2)
       if "__constructor__" in o2:
          return objDictToPyObject(o2)
       return o2 # This actually is a dictionary
    return o # This is some other type of object (error?)

def json_decode_list(o):
    del o["__myclass__"]
    n = len(o)
    lst=[json_decode_dictionaries(o[str(i)]) for i in range(n)]
    return lst

def json_decode_tuple(o):
    return tuple(json_decode_list(o))

'''Now we add support for objects that are instances of
 programmer-defined classes.
  '''

#def myJSONize(pyObj):
#    return json_encode(pyObj) #, default=pyObjectToDict)

#def myUnJSONize(jsonString):
#    return myjson.loads(jsonString, object_hook=objDictToPyObject)

def pyObjectToDict(ob):
    ''' This function not only returns the object's dictionary,
    but also puts the name of the class into it as the value
    of the new property "__constructor__". '''
    d = ob.__dict__.copy()
    name = type(ob).__name__
    if (name=="JSObject"):
       name = d["__class__"]
    #print("In pyObjectToDict, name = "+name)
    d['__constructor__'] = name
    if "__class__" in d: del d["__class__"]
    return d

def objDictToPyObject(d):
    '''This function takes a dictionary that is supposed to
    have an entry for "__constructor__" and uses the rest of
    the keys and values to construct an instance of an object
    using a class constructor with the same name as the
    value of the __constructor__ property. '''
    try:
      constructor_name = d['__constructor__']
      #print("constructor_name = "+constructor_name)
    except KeyError as e:
      print("dict d has no entry for '__constructor__'.")
      return d
    
    d.__delitem__('__constructor__')
    c = eval(constructor_name)
    obj = c(**d)
    #print(obj)
    return obj

class mypoint:
	def __init__(self, x, y):
		self.x = x
		self.y = y

def test():
  print("Beginning the test() in myjson.py...")
  mp = mypoint(** {'x':4, 'y':2})
  '''
  dd = pyObjectToDict(mp)
  print("dd = "); print(dd)
  mp2 = objDictToPyObject(dd)
  print("mp2 = "); print(mp2)
'''
  mylist = [1, 2, "three", mp, mp, {'nice': 'stuff', 'apoint': mp}]
  print("mylist = "+str(mylist))

  jsonStr = json_encode(mylist)
  print(jsonStr)

  newlist = json_decode(jsonStr)
  print(newlist)


#if (__name__=='__main__'): test()



      
